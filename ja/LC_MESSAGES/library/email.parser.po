# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# E. Kawashima, 2016
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2016-11-18 22:20+0000\n"
"Last-Translator: Julien <github@mandark.fr>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc/python-35/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/email.parser.rst:2
msgid ":mod:`email.parser`: Parsing email messages"
msgstr ":mod:`email.parser`: 電子メールメッセージのパース"

#: ../../library/email.parser.rst:7
msgid "**Source code:** :source:`Lib/email/parser.py`"
msgstr "**ソースコード:** :source:`Lib/email/parser.py`"

#: ../../library/email.parser.rst:11
msgid ""
"Message object structures can be created in one of two ways: they can be "
"created from whole cloth by instantiating :class:`~email.message.Message` "
"objects and stringing them together via "
":meth:`~email.message.Message.attach` and "
":meth:`~email.message.Message.set_payload` calls, or they can be created by "
"parsing a flat text representation of the email message."
msgstr "メッセージオブジェクト構造体の作成には 2 つの方法があります。\n一つ目は :class:`~email.message.Message` オブジェクトをインスタンス化し、\n:meth:`~email.message.Message.attach` と :meth:`~email.message.Message.set_payload` を呼び出しつなぎあわせることで、一から作る方法です。 \n二つ目は電子メールメッセージのフラットテクスト表現のパースです。"

#: ../../library/email.parser.rst:17
msgid ""
"The :mod:`email` package provides a standard parser that understands most "
"email document structures, including MIME documents.  You can pass the "
"parser a string or a file object, and the parser will return to you the root"
" :class:`~email.message.Message` instance of the object structure.  For "
"simple, non-MIME messages the payload of this root object will likely be a "
"string containing the text of the message.  For MIME messages, the root "
"object will return ``True`` from its "
":meth:`~email.message.Message.is_multipart` method, and the subparts can be "
"accessed via the :meth:`~email.message.Message.get_payload` and "
":meth:`~email.message.Message.walk` methods."
msgstr ":mod:`email` パッケージが提供する標準的なパーザ (解析器) は、MIME 文書を含むほとんどの電子メールの文書構造を解釈できます。\nパーザに文字列やファイルオブジェクトを渡せば、パーザはそのオブジェクト構造のルート :class:`~email.message.Message` インスタンスを返します。\n簡単な非 MIME メッセージの場合、このルートオブジェクトのペイロードはメッセージのテキストを含む文字列になるでしょう。\nMIME メッセージであれば、ルートオブジェクトの :meth:`~email.message.Message.is_multipart` メソッドは ``True`` を返します。\nルート下の要素には :meth:`~email.message.Message.get_payload` や :meth:`~email.message.Message.walk` メソッドによってアクセスすることができます。"

#: ../../library/email.parser.rst:27
msgid ""
"There are actually two parser interfaces available for use, the classic "
":class:`Parser` API and the incremental :class:`FeedParser` API.  The "
"classic :class:`Parser` API is fine if you have the entire text of the "
"message in memory as a string, or if the entire message lives in a file on "
"the file system. :class:`FeedParser` is more appropriate for when you're "
"reading the message from a stream which might block waiting for more input "
"(e.g. reading an email message from a socket).  The :class:`FeedParser` can "
"consume and parse the message incrementally, and only returns the root "
"object when you close the parser [#]_."
msgstr "実際には 2つのパーザインターフェイスが使用可能です。\n古典的な :class:`Parser` API と増分的な :class:`FeedParser` API です。\nメッセージのテキスト全体を文字列としてメモリ上に保持している場合や、メッセージ全体がファイルシステム上のファイルにある場合は\n古典的な :class:`Parser` API が良いです。\n入力待ちによるブロックがありえるようなストリームからメッセージを読んでいる場合 (例えば電子メールメッセージをソケットから読み込んでいる場合) は、:class:`FeedParser` の方が適切です。\n:class:`FeedParser` はメッセージを増分的に受け取ってパースします。\nパーザを閉じたときはルートオブジェクトのみを返します [#]_。"

#: ../../library/email.parser.rst:36
msgid ""
"Note that the parser can be extended in limited ways, and of course you can "
"implement your own parser completely from scratch.  There is no magical "
"connection between the :mod:`email` package's bundled parser and the "
":class:`~email.message.Message` class, so your custom parser can create "
"message object trees any way it finds necessary."
msgstr "パーザを拡張できる方法は制限されていることに注意してください。\nもちろん、自分でパーザを一から実装することはできます。\n:mod:`email` パッケージのバンドルされたパーザと :class:`~email.message.Message` クラスの間には不思議な関係はありませんから、カスタムパーザはそれが必要とするやりかたでメッセージオブジェクトツリーを作成することができます。"

#: ../../library/email.parser.rst:44
msgid "FeedParser API"
msgstr "FeedParser API"

#: ../../library/email.parser.rst:46
msgid ""
"The :class:`FeedParser`, imported from the :mod:`email.feedparser` module, "
"provides an API that is conducive to incremental parsing of email messages, "
"such as would be necessary when reading the text of an email message from a "
"source that can block (e.g. a socket).  The :class:`FeedParser` can of "
"course be used to parse an email message fully contained in a string or a "
"file, but the classic :class:`Parser` API may be more convenient for such "
"use cases.  The semantics and results of the two parser APIs are identical."
msgstr ":mod:`email.feedparser` モジュールからインポートされる :class:`FeedParser` は email メッセージをインクリメンタルに解析するのに向いた API を提供します。これは email メッセージのテキストを (ソケットなどの) 読み込みがブロックされる可能性のある情報源から入力するときに必要となります。もちろん :class:`FeedParser` は文字列またはファイルにすべて格納されている email メッセージを解析するのにも使うことができますが、このような場合には旧式の :class:`Parser` API のほうが便利かもしれません。これら 2つのパーザ API の意味論と得られる結果は同一です。"

#: ../../library/email.parser.rst:54
msgid ""
"The :class:`FeedParser`'s API is simple; you create an instance, feed it a "
"bunch of text until there's no more to feed it, then close the parser to "
"retrieve the root message object.  The :class:`FeedParser` is extremely "
"accurate when parsing standards-compliant messages, and it does a very good "
"job of parsing non-compliant messages, providing information about how a "
"message was deemed broken.  It will populate a message object's *defects* "
"attribute with a list of any problems it found in a message.  See the "
":mod:`email.errors` module for the list of defects that it can find."
msgstr ":class:`FeedParser` API は簡単です。まずインスタンスをつくり、それにテキストを (それ以上テキストが必要なくなるまで) 流しこみます。その後パーザを close すると根っこ (root) のメッセージオブジェクトが返されます。標準に従ったメッセージを解析する場合、 :class:`FeedParser` は非常に正確であり、標準に従っていないメッセージでもちゃんと動きます。そのさい、これはメッセージがどのように壊れていると認識されたかについての情報を残します。これはメッセージオブジェクトの *defects* 属性にリストとして現れ、メッセージ中に発見された問題が記録されます。パーザが検出できる障害 (defect) については :mod:`email.errors` モジュールを参照してください。"

#: ../../library/email.parser.rst:63
msgid "Here is the API for the :class:`FeedParser`:"
msgstr "以下は :class:`FeedParser` の API です:"

#: ../../library/email.parser.rst:68
msgid ""
"Create a :class:`FeedParser` instance.  Optional *_factory* is a no-argument"
" callable that will be called whenever a new message object is needed.  It "
"defaults to the :class:`email.message.Message` class."
msgstr ":class:`FeedParser` インスタンスを作成します。オプション引数 *_factory* には引数なしの callable を指定し、これはつねに新しいメッセージオブジェクトの作成が必要になったときに呼び出されます。デフォルトでは、これは :class:`email.message.Message` クラスになっています。"

#: ../../library/email.parser.rst:72 ../../library/email.parser.rst:130
#: ../../library/email.parser.rst:177
msgid ""
"If *policy* is specified (it must be an instance of a :mod:`~email.policy` "
"class) use the rules it specifies to update the representation of the "
"message.  If *policy* is not set, use the :class:`compat32 "
"<email.policy.Compat32>` policy, which maintains backward compatibility with"
" the Python 3.2 version of the email package.  For more information see the "
":mod:`~email.policy` documentation."
msgstr "*policy* が指定された場合 (それは :mod:`~email.policy` クラスのインスタンスでなければなりません) メッセージの表現を更新するために、ポリシーが指定するルールを用います。もし *policy* が設定されていなければ、 :class:`compat32 <email.policy.Compat32>` ポリシーが使われます。このポリシーは、 Python 3.2 バージョンの email パッケージとの後方互換性を維持します。詳細については :mod:`~email.policy` ドキュメンテーションを見てください。"

#: ../../library/email.parser.rst:79
msgid "Added the *policy* keyword."
msgstr "キーワード引数 *policy* が追加されました。"

#: ../../library/email.parser.rst:83
msgid ""
"Feed the :class:`FeedParser` some more data.  *data* should be a string "
"containing one or more lines.  The lines can be partial and the "
":class:`FeedParser` will stitch such partial lines together properly.  The "
"lines in the string can have any of the common three line endings, carriage "
"return, newline, or carriage return and newline (they can even be mixed)."
msgstr ":class:`FeedParser` にデータを供給します。 *data* は 1行または複数行からなる文字列を渡します。渡される行は完結していなくてもよく、その場合 :class:`FeedParser` は部分的な行を適切につなぎ合わせます。文字列中の各行は標準的な 3種類の行末文字 (復帰 CR、改行 LF、または CR+LF) どれかの組み合わせでよく、これらが混在してもかまいません。"

#: ../../library/email.parser.rst:92
msgid ""
"Closing a :class:`FeedParser` completes the parsing of all previously fed "
"data, and returns the root message object.  It is undefined what happens if "
"you feed more data to a closed :class:`FeedParser`."
msgstr ":class:`FeedParser` を close し、それまでに渡されたすべてのデータの解析を完了させ根っこ (root) のメッセージオブジェクトを返します。 :class:`FeedParser` を close したあとにさらにデータを feed した場合の挙動は未定義です。"

#: ../../library/email.parser.rst:99
msgid ""
"Works exactly like :class:`FeedParser` except that the input to the "
":meth:`~FeedParser.feed` method must be bytes and not string."
msgstr ":meth:`~FeedParser.feed` メソッドへの入力が文字列ではなくバイト列でなければならないことを除いて :class:`FeedParser` と同等に動作します。"

#: ../../library/email.parser.rst:106
msgid "Parser class API"
msgstr "Parser クラス API"

#: ../../library/email.parser.rst:108
msgid ""
"The :class:`Parser` class, imported from the :mod:`email.parser` module, "
"provides an API that can be used to parse a message when the complete "
"contents of the message are available in a string or file.  The "
":mod:`email.parser` module also provides header-only parsers, called "
":class:`HeaderParser` and :class:`BytesHeaderParser`, which can be used if "
"you're only interested in the headers of the message.  :class:`HeaderParser`"
" and :class:`BytesHeaderParser` can be much faster in these situations, "
"since they do not attempt to parse the message body, instead setting the "
"payload to the raw body as a string.  They have the same API as the "
":class:`Parser` and :class:`BytesParser` classes."
msgstr ":mod:`email.parser` から import される :class:`Parser` クラスはメッセージの内容が文字列やファイルで完全な状態のときに、メッセージのパースに利用できる API を提供しています。 :mod:`email.parser` モジュールはヘッダのみのパーサも提供しています。それは :class:`HeaderParser` や :class:`BytesHeaderParser` と呼ばれるパーサで、メッセージのヘッダにのみ興味があるときに利用できます。 :class:`HeaderParser` と :class:`BytesHeaderParser` はそのような状況でより速く動作します、なぜならそれらはメッセージボディのパースを試みる代わりにボディそのものを文字列としてペイロードに格納するからです。これらは :class:`Parser` や :class:`BytesParser` クラスと同じ API を持っています。"

#: ../../library/email.parser.rst:118
msgid "The BytesHeaderParser class."
msgstr "BytesHeaderParser クラス。"

#: ../../library/email.parser.rst:124
msgid ""
"The constructor for the :class:`Parser` class takes an optional argument "
"*_class*.  This must be a callable factory (such as a function or a class), "
"and it is used whenever a sub-message object needs to be created.  It "
"defaults to :class:`~email.message.Message` (see :mod:`email.message`).  The"
" factory will be called without arguments."
msgstr ":class:`Parser` クラスのコンストラクタです。オプション引数 *_class* をとることができます。これは呼び出し可能なオブジェクト (関数やクラス) でなければならず、メッセージ内コンポーネント (sub-message object) が作成されるときは常にそのファクトリクラスとして使用されます。デフォルトではこれは :class:`~email.message.Message` になっています (:mod:`email.message` 参照)。このファクトリクラスは引数なしで呼び出されます。"

#: ../../library/email.parser.rst:137
msgid ""
"Removed the *strict* argument that was deprecated in 2.4.  Added the "
"*policy* keyword."
msgstr "2.4 で非推奨になった *strict* 引数の削除。キーワード引数 *policy* の追加。"

#: ../../library/email.parser.rst:141
msgid "The other public :class:`Parser` methods are:"
msgstr "それ以外の :class:`Parser` メソッドは以下のとおりです:"

#: ../../library/email.parser.rst:146
msgid ""
"Read all the data from the file-like object *fp*, parse the resulting text, "
"and return the root message object.  *fp* must support both the "
":meth:`~io.TextIOBase.readline` and the :meth:`~io.TextIOBase.read` methods "
"on file-like objects."
msgstr "ファイルなどストリーム形式 (file-like) のオブジェクト *fp* からすべてのデータを読み込み、得られたテキストを解析して基底 (root) メッセージオブジェクト構造を返します。 *fp* はストリーム形式のオブジェクトで :meth:`~io.TextIOBase.readline` および :meth:`~io.TextIOBase.read` 両方のメソッドをサポートしている必要があります。"

#: ../../library/email.parser.rst:151
msgid ""
"The text contained in *fp* must be formatted as a block of :rfc:`2822` style"
" headers and header continuation lines, optionally preceded by an envelope "
"header.  The header block is terminated either by the end of the data or by "
"a blank line.  Following the header block is the body of the message (which "
"may contain MIME-encoded subparts)."
msgstr "*fp* に格納されているテキスト文字列は、一連の :rfc:`2822` 形式のヘッダおよびヘッダ継続行 (header continuation lines) によって構成されている必要があります。オプションとして、最初にエンペローブヘッダが来ることもできます。ヘッダ部分はデータの終端か、ひとつの空行によって終了したとみなされます。ヘッダ部分に続くデータはメッセージ本体となります (MIME エンコードされた subpart を含んでいるかもしれません)。"

#: ../../library/email.parser.rst:157 ../../library/email.parser.rst:201
msgid ""
"Optional *headersonly* is a flag specifying whether to stop parsing after "
"reading the headers or not.  The default is ``False``, meaning it parses the"
" entire contents of the file."
msgstr "オプション引数 *headersonly* はヘッダを読み終えた後にパースを止めるかを指定するフラグです。デフォルトは ``False`` で、ファイルの内容全体をパースします。"

#: ../../library/email.parser.rst:163
msgid ""
"Similar to the :meth:`parse` method, except it takes a string object instead"
" of a file-like object.  Calling this method on a string is exactly "
"equivalent to wrapping *text* in a :class:`~io.StringIO` instance first and "
"calling :meth:`parse`."
msgstr ":meth:`parse` メソッドに似ていますが、ファイルなどのストリーム形式のかわりに文字列を引数としてとるところが違います。文字列に対してこのメソッドを呼ぶことは、 *text* を :class:`~io.StringIO` インスタンスとして作成して :meth:`parse` を適用するのと同じです。"

#: ../../library/email.parser.rst:168 ../../library/email.parser.rst:212
msgid "Optional *headersonly* is as with the :meth:`parse` method."
msgstr "オプション引数 *headersonly* は :meth:`parse` メソッドものものと同様です。"

#: ../../library/email.parser.rst:173
msgid ""
"This class is exactly parallel to :class:`Parser`, but handles bytes input. "
"The *_class* and *strict* arguments are interpreted in the same way as for "
"the :class:`Parser` constructor."
msgstr "このクラスは :class:`Parser` と入力としてバイト列を扱うことを除いて、全く同じです。*_class* と *strict* 引数は :class:`Parser` のコンストラクタと同様に解釈されます。"

#: ../../library/email.parser.rst:184 ../../library/email.parser.rst:230
#: ../../library/email.parser.rst:242 ../../library/email.parser.rst:253
#: ../../library/email.parser.rst:265
msgid "Removed the *strict* argument.  Added the *policy* keyword."
msgstr "*strict* 引数の削除。キーワード引数 *policy* の追加。"

#: ../../library/email.parser.rst:189
msgid ""
"Read all the data from the binary file-like object *fp*, parse the resulting"
" bytes, and return the message object.  *fp* must support both the "
":meth:`~io.IOBase.readline` and the :meth:`~io.IOBase.read` methods on file-"
"like objects."
msgstr "バイナリ file-like オブジェクト *fp* からすべてのデータを読み込み、得られたバイト列を解析してメッセージオブジェクト構造を返します。 *fp* はストリーム形式のオブジェクトで :meth:`~io.IOBase.readline` および :meth:`~io.IOBase.read` 両方のメソッドをサポートしている必要があります。"

#: ../../library/email.parser.rst:194
msgid ""
"The bytes contained in *fp* must be formatted as a block of :rfc:`2822` "
"style headers and header continuation lines, optionally preceded by an "
"envelope header.  The header block is terminated either by the end of the "
"data or by a blank line.  Following the header block is the body of the "
"message (which may contain MIME-encoded subparts, including subparts with a "
":mailheader:`Content-Transfer-Encoding` of ``8bit``."
msgstr "*fp* に格納されているバイト列は、一連の :rfc:`2822` 形式のヘッダおよびヘッダ継続行 (header continuation lines) によって構成されている必要があります。オプションとして、最初にエンペローブヘッダが来ることもできます。ヘッダ部分はデータの終端か、ひとつの空行によって終了したとみなされます。ヘッダ部分に続くデータはメッセージ本体となります (:mailheader:`Content-Transfer-Encoding` が ``8bit`` の subpart も含めて、 MIME エンコードされた subpart を持っているかもしれません)。"

#: ../../library/email.parser.rst:207
msgid ""
"Similar to the :meth:`parse` method, except it takes a :term:`bytes-like "
"object` instead of a file-like object.  Calling this method is equivalent to"
" wrapping *text* in a :class:`~io.BytesIO` instance first and calling "
":meth:`parse`."
msgstr ":meth:`parse` メソッドに似ていますが、 file-like オブジェクトの代わりに :term:`bytes-like オブジェクト <bytes-like object>` を引数として取るところが違います。このメソッドを呼び出すことは、 *text* を :class:`~io.BytesIO` インスタンスでラップしてから :meth:`parse` を呼び出すのと等価です。"

#: ../../library/email.parser.rst:217
msgid ""
"Since creating a message object structure from a string or a file object is "
"such a common task, four functions are provided as a convenience.  They are "
"available in the top-level :mod:`email` package namespace."
msgstr "ファイルや文字列からメッセージオブジェクト構造を作成するのはかなりよくおこなわれる作業なので、便宜上次のような 4つの関数が提供されています。これらは :mod:`email` パッケージのトップレベルの名前空間で使用できます。"

#: ../../library/email.parser.rst:226
msgid ""
"Return a message object structure from a string.  This is exactly equivalent"
" to ``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as with"
" the :class:`~email.parser.Parser` class constructor."
msgstr "文字列からメッセージオブジェクト構造を作成して返します。これは ``Parser().parsestr(s)`` と完全に等価です。 *_class* および *policy* は :class:`~email.parser.Parser` クラスのコンストラクタと同様に解釈されます。"

#: ../../library/email.parser.rst:236
msgid ""
"Return a message object structure from a :term:`bytes-like object`.  This is"
" exactly equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* "
"and *strict* are interpreted as with the :class:`~email.parser.Parser` class"
" constructor."
msgstr ":term:`bytes-like オブジェクト <bytes-like object>` からメッセージオブジェクト構造を作成して返します。これは ``BytesParser().parsebytes(s)`` と完全に等価です。オプション引数 *_class* および *strict* は :class:`~email.parser.Parser` クラスのコンストラクタと同様に解釈されます。"

#: ../../library/email.parser.rst:248
msgid ""
"Return a message object structure tree from an open :term:`file object`. "
"This is exactly equivalent to ``Parser().parse(fp)``.  *_class* and *policy*"
" are interpreted as with the :class:`~email.parser.Parser` class "
"constructor."
msgstr "オープンされた :term:`file object` からメッセージオブジェクト構造を作成して返します。これは ``Parser().parse(fp)`` と完全に等価です。 *_class* および *policy* は :class:`~email.parser.Parser` クラスのコンストラクタと同様に解釈されます。"

#: ../../library/email.parser.rst:259
msgid ""
"Return a message object structure tree from an open binary :term:`file "
"object`.  This is exactly equivalent to ``BytesParser().parse(fp)``. "
"*_class* and *policy* are interpreted as with the "
":class:`~email.parser.Parser` class constructor."
msgstr "オープンされたバイナリ :term:`file object` からメッセージオブジェクト構造を作成して返します。これは ``BytesParser().parse(fp)`` と完全に等価です。 *_class* および *policy* は :class:`~email.parser.Parser` クラスのコンストラクタと同様に解釈されます。"

#: ../../library/email.parser.rst:268
msgid ""
"Here's an example of how you might use this at an interactive Python "
"prompt::"
msgstr "対話的な Python プロンプトでこの関数を使用するとすれば、このようになります::"

#: ../../library/email.parser.rst:275
msgid "Additional notes"
msgstr "追加事項"

#: ../../library/email.parser.rst:277
msgid "Here are some notes on the parsing semantics:"
msgstr "以下はテキスト解析の際に適用されるいくつかの規約です:"

#: ../../library/email.parser.rst:279
msgid ""
"Most non-\\ :mimetype:`multipart` type messages are parsed as a single "
"message object with a string payload.  These objects will return ``False`` "
"for :meth:`~email.message.Message.is_multipart`.  Their "
":meth:`~email.message.Message.get_payload` method will return a string "
"object."
msgstr "ほとんどの非 :mimetype:`multipart` 形式のメッセージは単一の文字列ペイロードをもつ単一のメッセージオブジェクトとして解析されます。このオブジェクトは :meth:`~email.message.Message.is_multipart` に対して ``False`` を返します。このオブジェクトに対する :meth:`~email.message.Message.get_payload` メソッドは文字列オブジェクトを返します。"

#: ../../library/email.parser.rst:284
msgid ""
"All :mimetype:`multipart` type messages will be parsed as a container "
"message object with a list of sub-message objects for their payload.  The "
"outer container message will return ``True`` for "
":meth:`~email.message.Message.is_multipart` and their "
":meth:`~email.message.Message.get_payload` method will return the list of "
":class:`~email.message.Message` subparts."
msgstr ":mimetype:`multipart` 形式のメッセージはすべてメッセージ内コンポーネント (sub-message object) のリストとして解析されます。外側のコンテナメッセージオブジェクトは :meth:`~email.message.Message.is_multipart` に対して ``True`` を返し、このオブジェクトに対する :meth:`~email.message.Message.get_payload` メソッドは :class:`~email.message.Message` subpart のリストを返します。"

#: ../../library/email.parser.rst:291
msgid ""
"Most messages with a content type of :mimetype:`message/\\*` (e.g. "
":mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will "
"also be parsed as container object containing a list payload of length 1.  "
"Their :meth:`~email.message.Message.is_multipart` method will return "
"``True``. The single element in the list payload will be a sub-message "
"object."
msgstr ":mimetype:`message/\\*` の Content-Type をもつほとんどのメッセージ (例: :mimetype:`message/delivery-status` や :mimetype:`message/rfc822` など) もコンテナメッセージオブジェクトとして解析されますが、ペイロードのリストの長さは 1 になります。このオブジェクトは :meth:`~email.message.Message.is_multipart` メソッドに対して ``True`` を返し、リスト内にあるひとつだけの要素がメッセージ内のコンポーネントオブジェクトになります。"

#: ../../library/email.parser.rst:297
msgid ""
"Some non-standards compliant messages may not be internally consistent about"
" their :mimetype:`multipart`\\ -edness.  Such messages may have a "
":mailheader:`Content-Type` header of type :mimetype:`multipart`, but their "
":meth:`~email.message.Message.is_multipart` method may return ``False``. If "
"such messages were parsed with the :class:`~email.parser.FeedParser`, they "
"will have an instance of the "
":class:`~email.errors.MultipartInvariantViolationDefect` class in their "
"*defects* attribute list.  See :mod:`email.errors` for details."
msgstr "いくつかの標準的でないメッセージは、 :mimetype:`multipart` の使い方に統一がとれていない場合があります。このようなメッセージは :mailheader:`Content-Type` ヘッダに :mimetype:`multipart` を指定しているものの、その :meth:`~email.message.Message.is_multipart` メソッドは ``False`` を返すことがあります。もしこのようなメッセージが :class:`~email.parser.FeedParser` によって解析されると、その *defects* 属性のリスト中には :class:`~email.errors.MultipartInvariantViolationDefect` クラスのインスタンスが現れます。詳しい情報については :mod:`email.errors` を参照してください。"

#: ../../library/email.parser.rst:307
msgid "Footnotes"
msgstr "脚注"

#: ../../library/email.parser.rst:308
msgid ""
"As of email package version 3.0, introduced in Python 2.4, the classic "
":class:`~email.parser.Parser` was re-implemented in terms of the "
":class:`~email.parser.FeedParser`, so the semantics and results are "
"identical between the two parsers."
msgstr "Python 2.4 から導入された email パッケージバージョン 3.0 では、旧式の :class:`~email.parser.Parser` は :class:`~email.parser.FeedParser` によって書き直されました。そのためパーザの意味論と得られる結果は 2 つのパーザで同一のものになります。"
