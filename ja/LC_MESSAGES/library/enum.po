# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# 
# Translators:
# E. Kawashima <e.kawaschima+transifex@gmail.com>, 2016
# Nozomu Kaneko <nozom.kaneko@gmail.com>, 2016
# Shun Sakurai, 2016
# 秘湯 <xwhhsprings@gmail.com>, 2016
msgid ""
msgstr ""
"Project-Id-Version: Python 3.5\n"
"Report-Msgid-Bugs-To: \n"
"PO-Revision-Date: 2016-10-05 11:48+0000\n"
"Last-Translator: 秘湯 <xwhhsprings@gmail.com>\n"
"Language-Team: Japanese (http://www.transifex.com/python-doc-ja/python-35/language/ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/enum.rst:2
msgid ":mod:`enum` --- Support for enumerations"
msgstr ":mod:`enum` --- 列挙型のサポート"

#: ../../library/enum.rst:14
msgid "**Source code:** :source:`Lib/enum.py`"
msgstr "**ソースコード:** :source:`Lib/enum.py`"

#: ../../library/enum.rst:18
msgid ""
"An enumeration is a set of symbolic names (members) bound to unique, "
"constant values.  Within an enumeration, the members can be compared by "
"identity, and the enumeration itself can be iterated over."
msgstr "列挙型は、一意の定数値に束縛された識別名 (メンバー) の集合です。列挙型の中でメンバーの同一性を比較でき、列挙型自身でイテレートが可能です。"

#: ../../library/enum.rst:24
msgid "Module Contents"
msgstr "モジュールコンテンツ"

#: ../../library/enum.rst:26
msgid ""
"This module defines two enumeration classes that can be used to define "
"unique sets of names and values: :class:`Enum` and :class:`IntEnum`.  It "
"also defines one decorator, :func:`unique`."
msgstr "このモジュールでは一意の名前と値の集合を定義するために使用する :class:`Enum` と :class:`IntEnum`、およびデコレーターを定義する :func:`unique` を提供しています。"

#: ../../library/enum.rst:32
msgid ""
"Base class for creating enumerated constants.  See section `Functional API`_"
" for an alternate construction syntax."
msgstr "列挙型定数を作成する基底クラスです。もうひとつの構築構文については `機能 API`_ を参照してください。"

#: ../../library/enum.rst:37
msgid ""
"Base class for creating enumerated constants that are also subclasses of "
":class:`int`."
msgstr ":class:`int` のサブクラスでもある列挙型定数を作成する基底クラスです。"

#: ../../library/enum.rst:42
msgid ""
"Enum class decorator that ensures only one name is bound to any one value."
msgstr "一つの名前だけがひとつの値に束縛されていることを保証する Enum クラスのデコレーターです。"

#: ../../library/enum.rst:46
msgid "Creating an Enum"
msgstr "Enum の作成"

#: ../../library/enum.rst:48
msgid ""
"Enumerations are created using the :keyword:`class` syntax, which makes them"
" easy to read and write.  An alternative creation method is described in "
"`Functional API`_.  To define an enumeration, subclass :class:`Enum` as "
"follows::"
msgstr "列挙型は読み書きが容易になるよう :keyword:`class` 文を使って作成します。もうひとつの作成方法は `機能 API`_ で説明しています。列挙型は以下のように :class:`Enum` のサブクラスとして定義します::"

#: ../../library/enum.rst:60
msgid "Nomenclature"
msgstr "用語"

#: ../../library/enum.rst:62
msgid "The class :class:`Color` is an *enumeration* (or *enum*)"
msgstr "クラス :class:`Color` は *列挙型* (または *Enum*) です"

#: ../../library/enum.rst:63
msgid ""
"The attributes :attr:`Color.red`, :attr:`Color.green`, etc., are "
"*enumeration members* (or *enum members*)."
msgstr "属性 :attr:`Color.red`、:attr:`Color.green`、その他は *列挙型のメンバー* (または *Enum メンバー*) です。"

#: ../../library/enum.rst:65
msgid ""
"The enum members have *names* and *values* (the name of :attr:`Color.red` is"
" ``red``, the value of :attr:`Color.blue` is ``3``, etc.)"
msgstr "列挙型のメンバーは *名前* と *値* を持ちます (:attr:`Color.red` の名前は ``red``、:attr:`Color.blue` の値は ``3`` など)"

#: ../../library/enum.rst:71
msgid ""
"Even though we use the :keyword:`class` syntax to create Enums, Enums are "
"not normal Python classes.  See `How are Enums different?`_ for more "
"details."
msgstr "Enum の作成に :keyword:`class` 文を使用するものの、Enum は通常の Python クラスではありません。詳細は `Enum はどう違うのか?`_ を参照してください。"

#: ../../library/enum.rst:75
msgid "Enumeration members have human readable string representations::"
msgstr "列挙型のメンバーは人が読める文字列表現を持ちます::"

#: ../../library/enum.rst:80
msgid "...while their ``repr`` has more information::"
msgstr "...その一方でそれらの ``repr`` はより多くの情報を持っています::"

#: ../../library/enum.rst:85
msgid "The *type* of an enumeration member is the enumeration it belongs to::"
msgstr "列挙型メンバーの *データ型* はそれが所属する列挙型になります::"

#: ../../library/enum.rst:93
msgid "Enum members also have a property that contains just their item name::"
msgstr "Enum メンバーは自身の名前を持つだけのプロパティも持っています::"

#: ../../library/enum.rst:98
msgid "Enumerations support iteration, in definition order::"
msgstr "列挙型は定義順でのイテレーションをサポートしています::"

#: ../../library/enum.rst:114
msgid ""
"Enumeration members are hashable, so they can be used in dictionaries and "
"sets::"
msgstr "列挙型のメンバーはハッシュ化可能なため、辞書や集合で使用できます::"

#: ../../library/enum.rst:124
msgid "Programmatic access to enumeration members and their attributes"
msgstr "列挙型メンバーおよびそれらの属性へのプログラム的アクセス"

#: ../../library/enum.rst:126
msgid ""
"Sometimes it's useful to access members in enumerations programmatically "
"(i.e. situations where ``Color.red`` won't do because the exact color is not"
" known at program-writing time).  ``Enum`` allows such access::"
msgstr "プログラム的にメンバーに番号でアクセスしたほうが便利な場合があります (例えばプログラムを書いている時点で正確な色がまだわからなく、``Color.red`` と書くのが無理な場合など)。``Enum`` はそのようなアクセスも許容します::"

#: ../../library/enum.rst:135
msgid "If you want to access enum members by *name*, use item access::"
msgstr "列挙型メンバーに *名前* でアクセスしたい場合はアイテムとしてアクセスできます::"

#: ../../library/enum.rst:142
msgid ""
"If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr "列挙型メンバーの :attr:`name` か :attr:`value` が必要な場合::"

#: ../../library/enum.rst:152
msgid "Duplicating enum members and values"
msgstr "列挙型メンバーと値の重複"

#: ../../library/enum.rst:154
msgid "Having two enum members with the same name is invalid::"
msgstr "同じ名前の列挙型メンバーを複数持つことはできません::"

#: ../../library/enum.rst:164
msgid ""
"However, two enum members are allowed to have the same value.  Given two "
"members A and B with the same value (and A defined first), B is an alias to "
"A.  By-value lookup of the value of A and B will return A.  By-name lookup "
"of B will also return A::"
msgstr "ただし、複数の列挙型メンバーが同じ値を持つことはできます。同じ値を持つ 2 つのメンバー A および B (先に定義したのは A) が与えられたとき、B は A の別名になります。A および B を値で調べたとき、A が返されます。B を名前で調べたとき、A が返されます::"

#: ../../library/enum.rst:184
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr "すでに定義されている属性と同じ名前のメンバー (一方がメンバーでもう一方がメソッド、など) の作成、あるいはメンバーと同じ名前の属性の作成はできません。"

#: ../../library/enum.rst:190
msgid "Ensuring unique enumeration values"
msgstr "番号付けの値が同一であることの確認"

#: ../../library/enum.rst:192
msgid ""
"By default, enumerations allow multiple names as aliases for the same value."
" When this behavior isn't desired, the following decorator can be used to "
"ensure each value is used only once in the enumeration:"
msgstr "デフォルトでは、前述のように複数の名前への同じ値の定義は別名とすることで許されています。この挙動を望まない場合、以下のデコレーターを使用することで各値が列挙型内で一意かどうか確認できます:"

#: ../../library/enum.rst:198
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  It searches an "
"enumeration's :attr:`__members__` gathering any aliases it finds; if any are"
" found :exc:`ValueError` is raised with the details::"
msgstr "列挙型専用の :keyword:`class` デコレーターです。列挙型の :attr:`__members__` に別名がないかどうか検索します; 見つかった場合、:exc:`ValueError` が詳細情報とともに送出されます::"

#: ../../library/enum.rst:216
msgid "Iteration"
msgstr "イテレーション"

#: ../../library/enum.rst:218
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "列挙型のメンバーのイテレートは別名をサポートしていません::"

#: ../../library/enum.rst:223
msgid ""
"The special attribute ``__members__`` is an ordered dictionary mapping names"
" to members.  It includes all names defined in the enumeration, including "
"the aliases::"
msgstr "特殊属性 ``__members__`` は名前をメンバーにマッピングする順序を記憶する辞書です。列挙型内で定義されたすべての名前を別名も含めて格納しています::"

#: ../../library/enum.rst:235
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr "属性 ``__members__`` は列挙型メンバーへの詳細なアクセスに使用できます。以下はすべての別名を探す例です::"

#: ../../library/enum.rst:243
msgid "Comparisons"
msgstr "比較"

#: ../../library/enum.rst:245
msgid "Enumeration members are compared by identity::"
msgstr "列挙型メンバーは同一性を比較できます::"

#: ../../library/enum.rst:254
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr "列挙型の値の順序の比較はサポートされて *いません*。Enum メンバーは整数ではありません (`IntEnum`_ を参照してください)::"

#: ../../library/enum.rst:262
msgid "Equality comparisons are defined though::"
msgstr "ただし等価の比較は定義されています::"

#: ../../library/enum.rst:271
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr "非列挙型の値との比較は常に不等となります (繰り返しになりますが、:class:`IntEnum` はこれと異なる挙動になるよう設計されています)::"

#: ../../library/enum.rst:280
msgid "Allowed members and attributes of enumerations"
msgstr "列挙型で許されるメンバーと属性"

#: ../../library/enum.rst:282
msgid ""
"The examples above use integers for enumeration values.  Using integers is "
"short and handy (and provided by default by the `Functional API`_), but not "
"strictly enforced.  In the vast majority of use-cases, one doesn't care what"
" the actual value of an enumeration is.  But if the value *is* important, "
"enumerations can have arbitrary values."
msgstr "上述の例では列挙型の値に整数を使用しています。整数の使用は短くて使いやすい (そして `機能 API`_ でデフォルトで提供されています) のですが、厳密には強制ではありません。ほとんどの事例では列挙型の実際の値が何かを気にしていません。しかし、値が重要で *ある* 場合、列挙型は任意の値を持つことができます。"

#: ../../library/enum.rst:288
msgid ""
"Enumerations are Python classes, and can have methods and special methods as"
" usual.  If we have this enumeration::"
msgstr "列挙型は Python のクラスであり、通常どおりメソッドや特殊メソッドを持つことができます::"

#: ../../library/enum.rst:308
msgid "Then::"
msgstr "上記の結果が以下のようになります::"

#: ../../library/enum.rst:317
msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, "
":meth:`__add__`, etc.) and descriptors (methods are also descriptors)."
msgstr "何が許されているかのルールは次のとおりです。先頭と末尾が 1 個のアンダースコアの名前は列挙型により予約されているため、使用できません。列挙型内で定義されたその他すべての名前は、その列挙型のメンバーとして使用できます。特殊メソッド (:meth:`__str__`, :meth:`__add__`, など) と、メソッドを含むデスクリプタ (記述子) は例外です。"

#: ../../library/enum.rst:323
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then whatever value(s) were given to the enum member will be passed into "
"those methods.  See `Planet`_ for an example."
msgstr "注意: 列挙型で :meth:`__new__` および/または :meth:`__init__` を定義した場合、列挙型メンバーに与えられた値はすべてこれらのメソッドに渡されます。例 `Planet`_ を参照してください。"

#: ../../library/enum.rst:329
msgid "Restricted subclassing of enumerations"
msgstr "列挙型のサブクラス化の制限事項"

#: ../../library/enum.rst:331
msgid ""
"Subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr "列挙型のサブクラスの作成はその列挙型にメンバーが一つも定義されていない場合のみ行なえます。従って以下は許されません::"

#: ../../library/enum.rst:341
msgid "But this is allowed::"
msgstr "以下のような場合は許されます::"

#: ../../library/enum.rst:352
msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr "メンバーが定義された列挙型のサブクラス化を許可すると、いくつかのデータ型およびインスタンスの重要な不変条件の違反を引き起こします。とはいえ、それが許可されると、列挙型のグループ間での共通の挙動を共有するという利点もあります。 (`OrderedEnum`_ の例を参照してください。)"

#: ../../library/enum.rst:359
msgid "Pickling"
msgstr "Pickle 化"

#: ../../library/enum.rst:361
msgid "Enumerations can be pickled and unpickled::"
msgstr "列挙型は pickle 化と unpickle 化が行えます::"

#: ../../library/enum.rst:368
msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr "通常の pickle 化の制限事項が適用されます: pickle 可能な列挙型はモジュールのトップレベルで定義されていなくてはならず、unpickle 化はモジュールからインポート可能でなければなりません。"

#: ../../library/enum.rst:374
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr "pickle プロトコルバージョン 4 では他のクラスで入れ子になった列挙型の pickle 化も容易です。"

#: ../../library/enum.rst:377
msgid ""
"It is possible to modify how Enum members are pickled/unpickled by defining "
":meth:`__reduce_ex__` in the enumeration class."
msgstr "Enum メンバーをどう pickle 化/unpickle 化するかは、列挙型クラス内の :meth:`__reduce_ex__` で定義することで変更できます。"

#: ../../library/enum.rst:382
msgid "Functional API"
msgstr "機能 API"

#: ../../library/enum.rst:384
msgid ""
"The :class:`Enum` class is callable, providing the following functional "
"API::"
msgstr ":class:`Enum` クラスは呼び出し可能で、以下の機能 API を提供しています::"

#: ../../library/enum.rst:396
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr "この API の動作は :class:`~collections.namedtuple` と似ています。:class:`Enum` 呼び出しの第 1 引数は列挙型の名前です。"

#: ../../library/enum.rst:399
msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of "
"2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr "第 2 引数は列挙型メンバー名の *ソース* です。空白で区切った名前の文字列、名前のシーケンス、キー/値のペアの 2 要素タプルのシーケンス、あるいは名前と値のマッピング (例: 辞書) を指定できます。最後の 2 個のオプションでは、列挙型へ任意の値を割り当てることができます。前の 2 つのオプションでは、1 から始まり増加していく整数を自動的に割り当てます (別の開始値を指定するには、``start`` 引数を使用します)。:class:`Enum` から派生した新しいクラスが返されます。言い換えれば、上記の :class:`Animal` への割り当ては以下と等価です::"

#: ../../library/enum.rst:415
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but enum members all evaluate to"
" ``True``."
msgstr "デフォルトの開始番号が ``0`` ではなく ``1`` である理由は、``0`` がブール演算子では ``False`` になりますが、すべての列挙型メンバーの評価は ``True`` でなければならないためです。"

#: ../../library/enum.rst:419
msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in separate module, and also may not work on IronPython or Jython)."
" The solution is to specify the module name explicitly as follows::"
msgstr "機能 API による Enum の pickle 化は、その列挙型がどのモジュールで作成されたかを見つけ出すためにフレームスタックの実装の詳細が使われるので、トリッキーになることがあります (例えば別のモジュールのユーティリティ関数を使うと失敗しますし、IronPython や Jython ではうまくいきません)。解決策は、以下のようにモジュール名を明示的に指定することです::"

#: ../../library/enum.rst:429
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new"
" Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr "``module`` が与えられない場合、Enum はそれがなにか決定できないため、新しい Enum メンバーは unpickle 化できなくなります; エラーをソースの近いところで発生させるため、pickle 化は無効になります。"

#: ../../library/enum.rst:433
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on "
":attr:`~definition.__qualname__` being set to the location where pickle will"
" be able to find the class.  For example, if the class was made available in"
" class SomeData in the global scope::"
msgstr "新しい pickle プロトコルバージョン 4 では、一部の状況において、pickle がクラスを発見するための場所の設定に :attr:`~definition.__qualname__` を参照します。例えば、そのクラスがグローバルスコープ内のクラス SomeData 内で利用可能とするには以下のように指定します::"

#: ../../library/enum.rst:440
msgid "The complete signature is::"
msgstr "完全な構文は以下のようになります::"

#: ../../library/enum.rst:444
msgid "What the new Enum class will record as its name."
msgstr "新しい Enum クラスに記録されるそれ自身の名前です。"

#: ../../library/enum.rst:446
msgid ""
"The Enum members.  This can be a whitespace or comma separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr "Enum のメンバーです。\n空白またはカンマで区切った文字列でも構いません (特記ない限り値は 1 から始まります)::"

#: ../../library/enum.rst:451
msgid "or an iterator of names::"
msgstr "または名前のイテレータで::"

#: ../../library/enum.rst:455
msgid "or an iterator of (name, value) pairs::"
msgstr "または (名前, 値) のペアのイテレータでも指定できます::"

#: ../../library/enum.rst:459
msgid "or a mapping::"
msgstr "またはマッピングでも指定できます::"

#: ../../library/enum.rst:463
msgid "name of module where new Enum class can be found."
msgstr "新しい Enum クラスが見つかるモジュールの名前です。"

#: ../../library/enum.rst:465
msgid "where in module new Enum class can be found."
msgstr "新しい Enum クラスが見つかるモジュールの場所です。"

#: ../../library/enum.rst:467
msgid "type to mix in to new Enum class."
msgstr "新しい Enum クラスに混ぜるデータ型です。"

#: ../../library/enum.rst:469
msgid "number to start counting at if only names are passed in."
msgstr "names のみが渡されたときにカウントを開始する数です。"

#: ../../library/enum.rst:471
msgid "The *start* parameter was added."
msgstr "*start* 引数が追加されました。"

#: ../../library/enum.rst:476
msgid "Derived Enumerations"
msgstr "派生列挙型"

#: ../../library/enum.rst:479
msgid "IntEnum"
msgstr "IntEnum"

#: ../../library/enum.rst:481
msgid ""
"A variation of :class:`Enum` is provided which is also a subclass of "
":class:`int`.  Members of an :class:`IntEnum` can be compared to integers; "
"by extension, integer enumerations of different types can also be compared "
"to each other::"
msgstr ":class:`Enum` の派生型で :class:`int` のサブクラスでもあります。:class:`IntEnum` のメンバーは整数と比較できます; 拡張により、異なる整数列挙型同士で比較できます::"

#: ../../library/enum.rst:502
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr "ただし、これらも標準の :class:`Enum` 列挙型とは比較できません::"

#: ../../library/enum.rst:515
msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ":class:`IntEnum` の値は他の用途では整数のように振る舞います::"

#: ../../library/enum.rst:524
msgid ""
"For the vast majority of code, :class:`Enum` is strongly recommended, since "
":class:`IntEnum` breaks some semantic promises of an enumeration (by being "
"comparable to integers, and thus by transitivity to other unrelated "
"enumerations).  It should be used only in special cases where there's no "
"other choice; for example, when integer constants are replaced with "
"enumerations and backwards compatibility is required with code that still "
"expects integers."
msgstr ":class:`IntEnum` は (整数と比較できることと、他の無関係な列挙型への移行性により) 列挙型の一部の意味論的な約束に反しているため、列挙型は原則として :class:`Enum` を使うことを強く推奨します。:class:`IntEnum` はそれを使うしか方法がない特殊な場合のみの使用にとどめてください; 例えば、整数の定数を列挙型に置き換えたとき、それが整数であると想定しているコードに対する後方互換性のためにそう振る舞う必要がある場合などです。"

#: ../../library/enum.rst:534
msgid "Others"
msgstr "その他"

#: ../../library/enum.rst:536
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ":class:`IntEnum` は :mod:`enum` モジュールの一部ですが、単独での実装もとても簡単に行なえます::"

#: ../../library/enum.rst:542
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`StrEnum` that mixes in :class:`str` instead of "
":class:`int`."
msgstr "ここでは似たような列挙型の派生を定義する方法を紹介します; 例えば、:class:`StrEnum` は :class:`int` ではなく :class:`str` で複合させたものです。"

#: ../../library/enum.rst:545
msgid "Some rules:"
msgstr "いくつかのルール:"

#: ../../library/enum.rst:547
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before "
":class:`Enum` itself in the sequence of bases, as in the :class:`IntEnum` "
"example above."
msgstr ":class:`Enum` のサブクラスを作成するとき、複合させるデータ型は、基底クラスの並びで :class:`Enum` 自身より先に記述しなければなりません (上記 :class:`IntEnum` の例を参照)。"

#: ../../library/enum.rst:550
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. "
":class:`int` above.  This restriction does not apply to mix-ins which only "
"add methods and don't specify another data type such as :class:`int` or "
":class:`str`."
msgstr ":class:`Enum` はあらゆるデータ型のメンバーを持てますが、いったん追加のデータ型 (:class:`int` や :class:`str` など) と複合させた後は、すべてのメンバーの値は、上記 :class:`int` のようにそのデータ型でなければならなくなります。この制限はメソッドの追加に対してのみ適用されません。"

#: ../../library/enum.rst:555
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr "他のデータ型と複合させた場合、:attr:`value` 属性は、それが等価であり、等価であると比較が行えても、列挙型メンバー自身とは *同じではありません*。"

#: ../../library/enum.rst:558
msgid ""
"%-style formatting:  `%s` and `%r` call the :class:`Enum` class's "
":meth:`__str__` and :meth:`__repr__` respectively; other codes (such as `%i`"
" or `%h` for IntEnum) treat the enum member as its mixed-in type."
msgstr "%-方式の書式:  `%s` および `%r` はそれぞれ :class:`Enum` クラスの :meth:`__str__` および :meth:`__repr__` を呼び出します。その他のコード (IntEnum の `%i` や `%h` など) は列挙型のメンバーを複合されたデータ型とみなします。"

#: ../../library/enum.rst:561
msgid ""
":meth:`str.format` (or :func:`format`) will use the mixed-in type's "
":meth:`__format__`.  If the :class:`Enum` class's :func:`str` or "
":func:`repr` is desired, use the `!s` or `!r` format codes."
msgstr ":meth:`str.format` (または :func:`format`) は mix-in データ型の :meth:`__format__` を使用します。:class:`Enum` クラスの :func:`str` や :func:`repr` を使用したい場合は、 `!s` や `!r` の書式コードを使用します。"

#: ../../library/enum.rst:567
msgid "Interesting examples"
msgstr "興味深い例"

#: ../../library/enum.rst:569
msgid ""
"While :class:`Enum` and :class:`IntEnum` are expected to cover the majority "
"of use-cases, they cannot cover them all.  Here are recipes for some "
"different types of enumerations that can be used directly, or as examples "
"for creating one's own."
msgstr ":class:`Enum` および :class:`IntEnum` は大多数の用途をカバーすることを期待していますが、そのすべてをカバーできているわけではありません。ここではいくつかの異なるデータ型を直接使用できる列挙型のレシピやそれを作成する例を紹介します。"

#: ../../library/enum.rst:576
msgid "AutoNumber"
msgstr "AutoNumber"

#: ../../library/enum.rst:578
msgid "Avoids having to specify the value for each enumeration member::"
msgstr "各列挙番号の値の指定を不要にします::"

#: ../../library/enum.rst:597
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ":meth:`__new__` メソッドが定義されていれば、Enum 番号の作成時に使用されます; これは Enum の :meth:`__new__` と置き換えられ、クラスが作成された後の既存の番号を取得に使用されます。"

#: ../../library/enum.rst:603
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../../library/enum.rst:605
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ":class:`IntEnum` をベースとしないため、通常の :class:`Enum` の不変条件 (他の列挙型と比較できないなど) のままで、メンバーを順序付けできる列挙型です::"

#: ../../library/enum.rst:639
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../../library/enum.rst:641
msgid ""
"Raises an error if a duplicate member name is found instead of creating an "
"alias::"
msgstr "値が同じメンバーが見つかった場合、別名を作るのではなく、エラーを送出します::"

#: ../../library/enum.rst:666
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr "これは Enum に別名を無効にするのと同様な振る舞いの追加や変更をおこなうためのサブクラス化に役立つ例です。単に別名を無効にしたいだけなら、 :func:`unique` デコレーターを使用して行えます。"

#: ../../library/enum.rst:672
msgid "Planet"
msgstr "Planet"

#: ../../library/enum.rst:674
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined the value of the enum "
"member will be passed to those methods::"
msgstr ":meth:`__new__` や :meth:`__init__` が定義されている場合、列挙型メンバーの値はこれらのメソッドに渡されます::"

#: ../../library/enum.rst:702
msgid "How are Enums different?"
msgstr "Enum はどう違うのか?"

#: ../../library/enum.rst:704
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived Enum"
" classes and their instances (members)."
msgstr "Enum は Enum 派生クラスやそれらのインスタンス (メンバー) 双方の多くの側面に影響を及ぼすカスタムメタクラスを持っています。"

#: ../../library/enum.rst:709
msgid "Enum Classes"
msgstr "Enum クラス"

#: ../../library/enum.rst:711
msgid ""
"The :class:`EnumMeta` metaclass is responsible for providing the "
":meth:`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods "
"that allow one to do things with an :class:`Enum` class that fail on a "
"typical class, such as `list(Color)` or `some_var in Color`.  "
":class:`EnumMeta` is responsible for ensuring that various other methods on "
"the final :class:`Enum` class are correct (such as :meth:`__new__`, "
":meth:`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ":class:`EnumMeta` メタクラスは、:meth:`__contains__`、:meth:`__dir__`、:meth:`__iter__` および標準的なクラスでは失敗するが :class:`Enum` クラスでは動作するその他のメソッド (`list(Color)` や `some_var in Color` など) を責任を持って提供します。:class:`EnumMeta` は最終的な :class:`Enum` クラスのさまざまなメソッド (:meth:`__new__`、:meth:`__getnewargs__`、:meth:`__str__` および :meth:`__repr__`) が正しいことを責任を持って保証します。"

#: ../../library/enum.rst:721
msgid "Enum Members (aka instances)"
msgstr "Enum メンバー (インスタンス)"

#: ../../library/enum.rst:723
msgid ""
"The most interesting thing about Enum members is that they are singletons. "
":class:`EnumMeta` creates them all while it is creating the :class:`Enum` "
"class itself, and then puts a custom :meth:`__new__` in place to ensure that"
" no new ones are ever instantiated by returning only the existing member "
"instances."
msgstr "Enum メンバーについて最も興味深いのは、それらがシングルトンであるということです。:class:`EnumMeta` は :class:`Enum` 自身を作成し、メンバーを作成し、新しいインスタンスが作成されていないかどうかを確認するために既存のメンバーインスタンスだけを返すカスタム :meth:`__new__` を追加します。"

#: ../../library/enum.rst:731
msgid "Finer Points"
msgstr "細かい点"

#: ../../library/enum.rst:733
msgid ""
":class:`Enum` members are instances of an :class:`Enum` class, and even "
"though they are accessible as `EnumClass.member`, they should not be "
"accessed directly from the member as that lookup may fail or, worse, return "
"something besides the :class:`Enum` member you looking for::"
msgstr ":class:`Enum`  メンバーは :class:`Enum` クラスのインスタンスであり、`EnumClass.member` としてアクセスできるものの、メンバーから直接アクセスすることはできません。直接アクセスをすると、その検索は失敗するか、さらに悪い場合には、探している  :class:`Enum`  メンバー以外のものを返す場合もあります::"

#: ../../library/enum.rst:750
msgid "The :attr:`__members__` attribute is only available on the class."
msgstr ":attr:`__members__` はクラスでのみ利用可能です。"

#: ../../library/enum.rst:752
msgid ""
"If you give your :class:`Enum` subclass extra methods, like the `Planet`_ "
"class above, those methods will show up in a :func:`dir` of the member, but "
"not of the class::"
msgstr ":class:`Enum` サブクラスに拡張メソッドを与えた場合、上述の `Planet`_ のように、それらメソッドはメンバーの :func:`dir` に表示されますが、クラスのそれには表示されません::"

#: ../../library/enum.rst:761
msgid ""
"The :meth:`__new__` method will only be used for the creation of the "
":class:`Enum` members -- after that it is replaced.  Any custom "
":meth:`__new__` method must create the object and set the :attr:`_value_` "
"attribute appropriately."
msgstr ":meth:`__new__` メソッドは :class:`Enum` メンバーの作成にのみ使用され、その後置き換えられます。カスタムした :meth:`__new__` メソッドは必ずこのオブジェクトを作成し、 :attr:`_value_` 属性を適切に設定しなければなりません。"

#: ../../library/enum.rst:766
msgid ""
"If you wish to change how :class:`Enum` members are looked up you should "
"either write a helper function or a :func:`classmethod` for the "
":class:`Enum` subclass."
msgstr ":class:`Enum` メンバーを調べる方法を変更したい場合は、 :class:`Enum` のサブクラスのためにヘルパー関数をまたは :func:`classmethod` を書かなければなりません。"
